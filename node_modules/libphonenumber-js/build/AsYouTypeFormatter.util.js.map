{"version":3,"sources":["../source/AsYouTypeFormatter.util.js"],"names":["DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","RegExp","countOccurences","symbol","string","count","split","character","repeat","times","result","cutAndStripNonPairedParens","cutBeforeIndex","stripNonPairedParens","slice","closeNonPairedParens","template","cut_before","retained_template","opening_braces","closing_braces","dangling_braces","length","i","push","pop","start","cleared_string","index","populateTemplateWithDigits","position","digits","digit","search","replace"],"mappings":";;;;;;;;;;;;AAAA;AACO,IAAMA,iBAAiB,GAAG,GAA1B,C,CAA8B;;;AACrC,IAAMC,yBAAyB,GAAG,IAAIC,MAAJ,CAAWF,iBAAX,CAAlC,C,CAEA;AACA;;AACO,SAASG,eAAT,CAAyBC,MAAzB,EAAiCC,MAAjC,EAAyC;AAC/C,MAAIC,KAAK,GAAG,CAAZ,CAD+C,CAE/C;AACA;AACA;AACA;AACA;;AACA,uBAAwBD,MAAM,CAACE,KAAP,CAAa,EAAb,CAAxB,kHAA0C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,QAA/BC,SAA+B;;AACzC,QAAIA,SAAS,KAAKJ,MAAlB,EAA0B;AACzBE,MAAAA,KAAK;AACL;AACD;;AACD,SAAOA,KAAP;AACA,C,CAED;AACA;;;AACO,SAASG,MAAT,CAAgBJ,MAAhB,EAAwBK,KAAxB,EAA+B;AACrC,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACd,WAAO,EAAP;AACA;;AACD,MAAIC,MAAM,GAAG,EAAb;;AACA,SAAOD,KAAK,GAAG,CAAf,EAAkB;AACjB,QAAIA,KAAK,GAAG,CAAZ,EAAe;AACdC,MAAAA,MAAM,IAAIN,MAAV;AACA;;AACDK,IAAAA,KAAK,KAAK,CAAV;AACAL,IAAAA,MAAM,IAAIA,MAAV;AACA;;AACD,SAAOM,MAAM,GAAGN,MAAhB;AACA;;AAEM,SAASO,0BAAT,CAAoCP,MAApC,EAA4CQ,cAA5C,EAA4D;AAClE,MAAIR,MAAM,CAACQ,cAAD,CAAN,KAA2B,GAA/B,EAAoC;AACnCA,IAAAA,cAAc;AACd;;AACD,SAAOC,oBAAoB,CAACT,MAAM,CAACU,KAAP,CAAa,CAAb,EAAgBF,cAAhB,CAAD,CAA3B;AACA;;AAEM,SAASG,oBAAT,CAA8BC,QAA9B,EAAwCC,UAAxC,EAAoD;AAC1D,MAAMC,iBAAiB,GAAGF,QAAQ,CAACF,KAAT,CAAe,CAAf,EAAkBG,UAAlB,CAA1B;AACA,MAAME,cAAc,GAAGjB,eAAe,CAAC,GAAD,EAAMgB,iBAAN,CAAtC;AACA,MAAME,cAAc,GAAGlB,eAAe,CAAC,GAAD,EAAMgB,iBAAN,CAAtC;AACA,MAAIG,eAAe,GAAGF,cAAc,GAAGC,cAAvC;;AACA,SAAOC,eAAe,GAAG,CAAlB,IAAuBJ,UAAU,GAAGD,QAAQ,CAACM,MAApD,EAA4D;AAC3D,QAAIN,QAAQ,CAACC,UAAD,CAAR,KAAyB,GAA7B,EAAkC;AACjCI,MAAAA,eAAe;AACf;;AACDJ,IAAAA,UAAU;AACV;;AACD,SAAOD,QAAQ,CAACF,KAAT,CAAe,CAAf,EAAkBG,UAAlB,CAAP;AACA;;AAEM,SAASJ,oBAAT,CAA8BT,MAA9B,EAAsC;AAC5C,MAAMiB,eAAe,GAAE,EAAvB;AACA,MAAIE,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGnB,MAAM,CAACkB,MAAlB,EAA0B;AACzB,QAAIlB,MAAM,CAACmB,CAAD,CAAN,KAAc,GAAlB,EAAuB;AACtBF,MAAAA,eAAe,CAACG,IAAhB,CAAqBD,CAArB;AACA,KAFD,MAGK,IAAInB,MAAM,CAACmB,CAAD,CAAN,KAAc,GAAlB,EAAuB;AAC3BF,MAAAA,eAAe,CAACI,GAAhB;AACA;;AACDF,IAAAA,CAAC;AACD;;AACD,MAAIG,KAAK,GAAG,CAAZ;AACA,MAAIC,cAAc,GAAG,EAArB;AACAN,EAAAA,eAAe,CAACG,IAAhB,CAAqBpB,MAAM,CAACkB,MAA5B;;AACA,uCAAoBD,eAApB,wCAAqC;AAAhC,QAAMO,KAAK,wBAAX;AACJD,IAAAA,cAAc,IAAIvB,MAAM,CAACU,KAAP,CAAaY,KAAb,EAAoBE,KAApB,CAAlB;AACAF,IAAAA,KAAK,GAAGE,KAAK,GAAG,CAAhB;AACA;;AACD,SAAOD,cAAP;AACA;;AAEM,SAASE,0BAAT,CAAoCb,QAApC,EAA8Cc,QAA9C,EAAwDC,MAAxD,EAAgE;AACtE;AACA;AACA;AACA;AACA;AACA,wBAAoBA,MAAM,CAACzB,KAAP,CAAa,EAAb,CAApB,yHAAsC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,QAA3B0B,KAA2B;;AACrC;AACA;AACA;AACA;AACA,QAAIhB,QAAQ,CAACF,KAAT,CAAegB,QAAQ,GAAG,CAA1B,EAA6BG,MAA7B,CAAoCjC,yBAApC,IAAiE,CAArE,EAAwE;AACvE;AACA;;AACD8B,IAAAA,QAAQ,GAAGd,QAAQ,CAACiB,MAAT,CAAgBjC,yBAAhB,CAAX;AACAgB,IAAAA,QAAQ,GAAGA,QAAQ,CAACkB,OAAT,CAAiBlC,yBAAjB,EAA4CgC,KAA5C,CAAX;AACA;;AACD,SAAO,CAAChB,QAAD,EAAWc,QAAX,CAAP;AACA","sourcesContent":["// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function populateTemplateWithDigits(template, position, digits) {\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for `digits` it is safe.\r\n\t// for (const digit of digits)\r\n\tfor (const digit of digits.split('')) {\r\n\t\t// If there is room for more digits in current `template`,\r\n\t\t// then set the next digit in the `template`,\r\n\t\t// and return the formatted digits so far.\r\n\t\t// If more digits are entered than the current format could handle.\r\n\t\tif (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tposition = template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\ttemplate = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t}\r\n\treturn [template, position]\r\n}"],"file":"AsYouTypeFormatter.util.js"}