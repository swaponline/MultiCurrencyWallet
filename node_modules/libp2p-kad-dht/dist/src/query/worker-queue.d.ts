export = WorkerQueue;
/**
 * @typedef {import('peer-id')} PeerId
 */
declare class WorkerQueue {
    /**
     * Creates a new WorkerQueue.
     *
     * @param {import('../index')} dht
     * @param {import('./run')} run
     * @param {import('./path')} path
     * @param {Function & {error: Function}} log
     */
    constructor(dht: import('../index'), run: import('./run'), path: import('./path'), log: Function & {
        error: Function;
    });
    dht: import("..");
    run: import("./run");
    path: import("./path");
    log: Function & {
        error: Function;
    };
    concurrency: number;
    queue: Queue<import("p-queue/dist/priority-queue").default, import("p-queue").DefaultAddOptions>;
    /** @type {{ resolve: (result?: any) => void, reject: (err: Error) => void} | null} */
    execution: {
        resolve: (result?: any) => void;
        reject: (err: Error) => void;
    } | null;
    /** @type {Set<PeerId>} */
    queuedPeerIds: Set<PeerId>;
    /**
     * Create the underlying async queue.
     *
     * @returns {Queue}
     */
    setupQueue(): Queue;
    /**
     * Stop the worker, optionally providing an error to pass to the worker's
     * callback.
     *
     * @param {Error} [err]
     */
    stop(err?: Error | undefined): void;
    running: boolean | undefined;
    /**
     * Use the queue from async to keep `concurrency` amount items running
     * per path.
     *
     * @returns {Promise<void>}
     */
    execute(): Promise<void>;
    /**
     * Add peers to the worker queue until there are enough to satisfy the
     * worker queue concurrency.
     * Note that we don't want to take any more than those required to satisfy
     * concurrency from the peers-to-query queue, because we always want to
     * query the closest peers to the key first, and new peers are continuously
     * being added to the peers-to-query queue.
     */
    fill(): void;
    /**
     * Process the next peer in the queue
     *
     * @param {PeerId} peer
     */
    processNext(peer: PeerId): Promise<void>;
    /**
     * Execute a query on the next peer.
     *
     * @param {PeerId} peer
     */
    execQuery(peer: PeerId): Promise<{
        pathComplete: boolean | undefined;
        queryComplete: boolean | undefined;
    } | undefined>;
}
declare namespace WorkerQueue {
    export { PeerId };
}
import { default as Queue } from "p-queue";
type PeerId = import("peer-id");
//# sourceMappingURL=worker-queue.d.ts.map