export = Query;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {{from: PeerId, val: Uint8Array}} DHTQueryValue
 * @typedef {{from: PeerId, err: Error}} DHTQueryError
 * @typedef {DHTQueryValue | DHTQueryError} DHTQueryResult
 * @typedef {import('../').PeerData} PeerData
 *
 * @typedef {{ pathComplete?: boolean, queryComplete?: boolean, closerPeers?: PeerData[], peer?: PeerData, success?: boolean }} QueryResult
 */
/**
 * User-supplied function to set up an individual disjoint path. Per-path
 * query state should be held in this function's closure.
 *
 * Accepts the numeric index from zero to numPaths - 1 and returns a function
 * to call on each peer in the query.
 *
 * @typedef {(pathIndex: number, numPaths: number) => QueryFunc } MakeQueryFunc
 */
/**
 * Query function
 *
 * @typedef {(peer: PeerId) => Promise<QueryResult> } QueryFunc
 */
/**
 * Divide peers up into disjoint paths (subqueries). Any peer can only be used once over all paths.
 * Within each path, query peers from closest to farthest away.
 */
declare class Query {
    /**
     * Create a new query. The makePath function is called once per disjoint path, so that per-path
     * variables can be created in that scope. makePath then returns the actual query function (queryFunc) to
     * use when on that path.
     *
     * @param {import('../index')} dht - DHT instance
     * @param {Uint8Array} key
     * @param {MakeQueryFunc} makePath - Called to set up each disjoint path. Must return the query function.
     */
    constructor(dht: import('../index'), key: Uint8Array, makePath: MakeQueryFunc);
    dht: import("..");
    key: Uint8Array;
    makePath: MakeQueryFunc;
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    running: boolean;
    /**
     * Called when the run starts.
     */
    _onStart(): void;
    /**
     * Called when the run completes (even if there's an error).
     */
    _onComplete(): void;
    /**
     * Run this query, start with the given list of peers first.
     *
     * @param {PeerId[]} peers
     */
    run(peers: PeerId[]): Promise<{
        finalSet: Set<import("peer-id")>;
        paths: QueryResult[];
    } | {
        finalSet: Set<any>;
        paths: never[];
    }>;
    _run: Run | undefined;
    _startTime: number | undefined;
    /**
     * Stop the query.
     */
    stop(): void;
}
declare namespace Query {
    export { PeerId, DHTQueryValue, DHTQueryError, DHTQueryResult, PeerData, QueryResult, MakeQueryFunc, QueryFunc };
}
/**
 * User-supplied function to set up an individual disjoint path. Per-path
 * query state should be held in this function's closure.
 *
 * Accepts the numeric index from zero to numPaths - 1 and returns a function
 * to call on each peer in the query.
 */
type MakeQueryFunc = (pathIndex: number, numPaths: number) => QueryFunc;
type PeerId = import("peer-id");
type QueryResult = {
    pathComplete?: boolean | undefined;
    queryComplete?: boolean | undefined;
    closerPeers?: import("..").PeerData[] | undefined;
    peer?: import("..").PeerData | undefined;
    success?: boolean | undefined;
};
import Run = require("./run");
type DHTQueryValue = {
    from: PeerId;
    val: Uint8Array;
};
type DHTQueryError = {
    from: PeerId;
    err: Error;
};
type DHTQueryResult = DHTQueryValue | DHTQueryError;
type PeerData = {
    id: import("peer-id");
    multiaddrs: import("multiaddr")[];
};
/**
 * Query function
 */
type QueryFunc = (peer: PeerId) => Promise<QueryResult>;
//# sourceMappingURL=index.d.ts.map