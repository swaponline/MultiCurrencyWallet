---
status: planned
depends_on: [2]
wave: 3
skills: [code-writing]
verify: bash
reviewers: [code-reviewer, security-auditor, test-reviewer]
---

# Task 4: Biometric Authentication + Auto-lock

## Required Skills

Before starting, load:
- `/skill:code-writing` — [~/.claude/skills/code-writing/SKILL.md](~/.claude/skills/code-writing/SKILL.md)

## Description

Implement BiometricPrompt integration in `:core:auth` module with app password fallback, exponential backoff lockout with persisted failure counter, password-only mode for devices without biometric hardware, and auto-lock per Decision 12 (5-minute inactivity timer, 30-second background timeout).

Security model: Strong authentication required for all wallet operations. Biometric preferred, password fallback. Exponential lockout after 5 failed attempts (60s, 120s, 300s). Auto-lock prevents unauthorized access on unattended devices.

## What to do

1. Create AuthManager class in `:core:auth` with authentication orchestration
2. Implement checkBiometricAvailability() using BiometricManager — returns BIOMETRIC_SUCCESS, BIOMETRIC_ERROR_NO_HARDWARE, or BIOMETRIC_ERROR_NONE_ENROLLED
3. Implement authenticateWithBiometric() using BiometricPrompt — callback with success/failure
4. Implement authenticateWithPassword(password: String) — verify against stored bcrypt hash, handle lockout
5. Implement biometric fallback: after 3 biometric failures → show password prompt
6. Implement password lockout logic: track failed attempts (persist in SecureStorage), exponential backoff (60s, 120s, 300s), lockout timer display
7. Implement auto-lock: 5-minute inactivity timer (reset on user interaction), 30-second background timer (start when app moves to background), locked state requires re-authentication
8. Create LockState sealed class (Unlocked, Locked, LockedOut(untilTimestamp))
9. Expose lockStateFlow: StateFlow<LockState>
10. Write unit tests for password verification, lockout logic, auto-lock timers

## TDD Anchor

tests/core/auth/AuthManagerTest.kt:
- testPasswordVerification — correct password → success, wrong password → failure
- testLockoutAfter5Failures — 5 wrong passwords → LockedOut state, 60s timer
- testLockoutProgression — fail, wait, fail 5 more → 120s timer, then 300s
- testLockoutPersistence — fail 3 times, simulate app restart, fail 2 more → lockout triggered (counter persisted)
- testBiometricFallbackAfter3Failures — mock 3 biometric failures → password prompt shown
- testAutoLock5Minutes — mock 5 minutes inactivity → lockState transitions to Locked
- testAutoLock30SecondsBackground — mock app backgrounded for 30s → Locked
- testUserInteractionResetsInactivityTimer — mock interaction → verify timer reset

## Acceptance Criteria

- [ ] BiometricPrompt integration working
- [ ] Password authentication verifies against bcrypt hash
- [ ] Lockout triggers after 5 failed password attempts
- [ ] Exponential backoff: 60s, 120s, 300s (persisted across restarts)
- [ ] Biometric failures (3x) fall back to password prompt
- [ ] Devices without biometric hardware show password prompt immediately
- [ ] Auto-lock: 5 minutes inactivity
- [ ] Auto-lock: 30 seconds in background
- [ ] User interaction resets inactivity timer
- [ ] All unit tests pass

## Context Files

- [user-spec.md](../user-spec.md)
- [tech-spec.md](../tech-spec.md)

## Verification Steps

1. Run: `cd android && ./gradlew :core:auth:test`
2. Expected: All tests pass
3. Verify lockout test shows exponential backoff (60s, 120s, 300s)
4. Verify persistence test shows failure counter survives "restart" (storage mock)
5. Verify auto-lock tests show timer behavior

## Details

**BiometricPrompt setup:**
```kotlin
val promptInfo = BiometricPrompt.PromptInfo.Builder()
    .setTitle("Authenticate")
    .setSubtitle("Unlock your wallet")
    .setNegativeButtonText("Use password")
    .build()

val biometricPrompt = BiometricPrompt(
    activity,
    executor,
    object : BiometricPrompt.AuthenticationCallback() {
        override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
            // Success
        }
        override fun onAuthenticationFailed() {
            biometricFailureCount++
            if (biometricFailureCount >= 3) showPasswordPrompt()
        }
    }
)

biometricPrompt.authenticate(promptInfo)
```

**Password lockout storage:**
- Store in SecureStorage: `password_failure_count` (Int), `lockout_until` (Long epoch millis)
- Increment failure counter on wrong password
- After 5 failures: set `lockout_until = now + 60000` (60s), increment lockout level
- Next lockout: 120s, then 300s
- Successful password → reset counter to 0

**Exponential backoff:**
| Attempt | Lockout Duration |
|---------|------------------|
| 1-4 | No lockout |
| 5 | 60 seconds |
| 6-9 (after first lockout) | 120 seconds |
| 10+ (after second lockout) | 300 seconds |

**Auto-lock timers:**
- Inactivity timer: 5 minutes (300000 ms)
- Reset on: touch events, button clicks, navigation
- Background timer: start in `onPause()`, check duration in `onResume()`
- If backgrounded >30s → lock immediately

**LockState:**
```kotlin
sealed class LockState {
    object Unlocked : LockState()
    object Locked : LockState()
    data class LockedOut(val untilTimestamp: Long) : LockState()
}
```

**Biometric availability:**
```kotlin
when (biometricManager.canAuthenticate(BIOMETRIC_STRONG)) {
    BIOMETRIC_SUCCESS -> showBiometricPrompt()
    BIOMETRIC_ERROR_NO_HARDWARE, 
    BIOMETRIC_ERROR_NONE_ENROLLED -> showPasswordPrompt()
}
```

**Edge cases:**
- Device has fingerprint but user hasn't enrolled → show password prompt
- Biometric prompt cancelled by user → treat as failure
- System time changed during lockout → validate lockout_until against current time, clear if in past
- App killed during lockout → lockout persists via storage

**Implementation hints:**
- Use CoroutineScope for timers (delay())
- Inject SecureStorage for persistence
- Expose StateFlow<LockState> for UI observation
- Use @HiltViewModel if AuthManager is used in ViewModel

## Reviewers

- **code-reviewer** → `logs/working/task-4/code-reviewer-{round}.json`
- **security-auditor** → `logs/working/task-4/security-auditor-{round}.json`
- **test-reviewer** → `logs/working/task-4/test-reviewer-{round}.json`

## Post-completion

- [ ] Write report to decisions.md (include all review rounds with links)
- [ ] If deviated from spec — describe deviation and reason
- [ ] Update user-spec/tech-spec if anything changed
