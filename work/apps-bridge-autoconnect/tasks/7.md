---
status: done
depends_on: [1]
wave: 3
skills: [code-writing]
verify: bash
reviewers: [test-reviewer]
teammate_name:
---

# Task 7: Add MCW bridge unit tests

## Required Skills

Before starting, load:
- `/skill:code-writing` — [~/.claude/skills/code-writing/SKILL.md](~/.claude/skills/code-writing/SKILL.md)

## Description

Create comprehensive unit tests for the wallet apps bridge protocol in MCW. The bridge client (`wallet-apps-bridge-client.js`) implements an EIP-1193-compliant provider that communicates with the MCW wallet host via postMessage. This task writes tests for existing bridge code from Task 1 to ensure the bridge protocol is properly covered by unit tests, verifying correct handshake flow, request/response handling, event forwarding, and provider properties.

The tests verify that:
1. The bridge provider has correct properties (isMetaMask flag, bridge-specific flags, chainId, selectedAddress)
2. The postMessage handshake (HELLO → READY) works correctly
3. Requests are forwarded to the host and Promises resolve with the correct response
4. Events from the host (accountsChanged, chainChanged, disconnect) are properly forwarded to listeners

These tests verify existing bridge code from Task 1. The bridge protocol is already implemented — this task adds test coverage to ensure it works reliably before dApps depend on it for auto-connect functionality.

## What to do

1. Create new test file `tests/unit/walletBridge.test.ts`
2. Set up test environment that mocks `window`, `window.parent`, and `postMessage` API
3. Write test scenarios covering:
   - Bridge provider property verification (isMetaMask, isSwapWalletAppsBridge, chainId, selectedAddress)
   - HELLO → READY handshake flow with account and chainId payload
   - Request forwarding (eth_accounts, eth_requestAccounts) with Promise resolution
   - Event forwarding (accountsChanged, chainChanged, disconnect events)
   - Error handling (timeout, host error responses)
4. Ensure all tests pass with `npm run test:unit`


## Acceptance Criteria

- [ ] AC1: Test file `tests/unit/walletBridge.test.ts` exists and contains all test scenarios
- [ ] AC2: All bridge provider properties (isMetaMask, isSwapWalletAppsBridge, chainId, selectedAddress) are verified in tests
- [ ] AC3: HELLO → READY handshake flow is tested with mock postMessage
- [ ] AC4: Request forwarding is tested for both eth_accounts and eth_requestAccounts methods
- [ ] AC5: Event forwarding is tested for accountsChanged, chainChanged, and disconnect events
- [ ] AC6: Error handling is tested (timeout, error responses from host)
- [ ] AC7: All tests pass when running `npm run test:unit`
- [ ] AC8: Test coverage includes both success and error paths
- [ ] AC9: Tests use Jest mocking properly (mock window.parent.postMessage, window.addEventListener)
- [ ] AC10: No regressions in existing unit tests

## Context Files

**Feature-specific:**
- [user-spec.md](../user-spec.md)
- [tech-spec.md](../tech-spec.md)
- [decisions.md](../decisions.md)

**Project context (always):**
- [project.md](/root/MultiCurrencyWallet/.claude/skills/project-knowledge/references/project.md)
- [architecture.md](/root/MultiCurrencyWallet/.claude/skills/project-knowledge/references/architecture.md)

**By task relevance:**
- [patterns.md](/root/MultiCurrencyWallet/.claude/skills/project-knowledge/references/patterns.md) — Testing & Verification section, code conventions

**Code files:**
- Bridge client implementation (on branch issue-5268-apps-layout): `src/front/client/wallet-apps-bridge-client.js`
- Example unit test structure: `tests/unit/btcSend.test.ts`

## Verification Steps

1. Run unit tests: `npm run test:unit` in MCW repo
2. Verify new test file `tests/unit/walletBridge.test.ts` appears in test output
3. Verify all test cases pass (9 scenarios: properties, handshake, 2 request types, 3 event types, timeout, error)
4. Check test coverage: all critical bridge protocol flows covered
5. Verify no regressions: existing unit tests still pass

## Details

**Files:**

- `tests/unit/walletBridge.test.ts` (NEW) — Create unit test file with all test scenarios. Structure:
  - Setup: Mock DOM environment (JSDOM provides window, but need to mock iframe context)
  - Mock `window.parent` (parent window for postMessage)
  - Mock `postMessage` to capture outgoing messages
  - Load bridge client code (either via dynamic import or inline eval in test setup)
  - Test suites organized by protocol aspect (properties, handshake, requests, events, errors)

**Current bridge client implementation (on branch issue-5268-apps-layout):**

Key properties to test:
- `window.ethereum.isSwapWalletAppsBridge === true` (bridge identifier)
- `window.ethereum.isMetaMask` (currently false, will be changed to true in Task 1)
- `window.ethereum.chainId` (set from READY payload)
- `window.ethereum.selectedAddress` (set from READY payload accounts[0])
- `window.ethereum.isConnected()` (returns true after READY)

Key methods to test:
- `window.ethereum.request({ method, params })` — Returns Promise, sends BRIDGE_REQUEST via postMessage
- `window.ethereum.enable()` — Alias for eth_requestAccounts
- `window.ethereum.on(eventName, callback)` — Event listener registration
- `window.ethereum.send(method, params)` — Legacy method, wraps request()
- `window.ethereum.sendAsync(payload, callback)` — Callback-based, wraps request()

postMessage protocol:
- **Client → Host:** `{ source: 'swap.wallet.apps.bridge.client', type: 'WALLET_APPS_BRIDGE_HELLO', payload: { version, ua } }`
- **Host → Client:** `{ source: 'swap.wallet.apps.bridge.host', type: 'WALLET_APPS_BRIDGE_READY', payload: { providerAvailable, chainId, accounts, methods, methodPrefixes } }`
- **Client → Host:** `{ source: 'swap.wallet.apps.bridge.client', type: 'WALLET_APPS_BRIDGE_REQUEST', payload: { requestId, method, params } }`
- **Host → Client:** `{ source: 'swap.wallet.apps.bridge.host', type: 'WALLET_APPS_BRIDGE_RESPONSE', payload: { requestId, result?, error? } }`
- **Host → Client:** `{ source: 'swap.wallet.apps.bridge.host', type: 'WALLET_APPS_BRIDGE_EVENT', payload: { eventName, data } }`

**Dependencies:**

- Task 1 must be complete (isMetaMask flag change). However, tests can verify current state and document expected behavior.
- No new packages needed — Jest already installed, JSDOM provides DOM mocking

**Edge cases:**

- Bridge client only runs in iframe context (`window.parent !== window`). Tests must mock this.
- Request timeout is 30 seconds. Use Jest fake timers to test timeout without waiting.
- Multiple listeners on same event must all be called.
- Removing specific listener vs removeAllListeners behavior.
- Error responses from host (with code and message).
- Empty accounts array triggers disconnect event.

**Implementation hints:**

- Use `beforeEach` to reset mocks and re-initialize bridge client for each test
- Mock `window.parent.postMessage` with Jest: `window.parent = { postMessage: jest.fn() }`
- Simulate host messages by calling `window.dispatchEvent(new MessageEvent('message', { source: window.parent, data: {...} }))`
- Use `jest.useFakeTimers()` to test timeout without 30-second wait
- Look at `tests/unit/btcSend.test.ts` for Jest structure and patterns (describe blocks, async tests, expect assertions, custom matchers)
- Bridge client is an IIFE (immediately invoked function expression) — tests may need to reload it between test cases or use separate test environment instances
- Tests verify existing code from Task 1, not new implementation. If Task 1 is not merged yet, tests will pass once Task 1 changes (isMetaMask: true) are deployed

## Reviewers

- **test-reviewer** → `logs/working/task-7/test-reviewer-{round}.json`

## Post-completion

- [ ] Write brief report to decisions.md following template (Summary: 1-3 sentences, reviews with links to JSON, no finding tables or dumps)
- [ ] If deviated from spec — describe deviation and reason
- [ ] Update user-spec/tech-spec if anything changed
